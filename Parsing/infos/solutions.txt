    case: |>>
    first iteration = pipe -> flag_sync_sc = 0 & index = 0; (|)
    sec iteration = red_app -> flag_sync_sc = 1 & index = 1; 2 all flags desactivated (does not affect) (>)
    third iteration = (>) -> flag_sync_sc = 2 & index = 2; 4 all flags desactivated again resulting in > to be identifed

    ls |>> (strings case)

    first iteration = string -> flag_sync_string = 3 & index = 2; => 5 (ls )
    sec iteration = pipe -> flag_sync_sc = 0 & index = 3 & flag_sync_string = 3; => 6 (|)
    third iteration = red_app -> flag_sync_sc = 1 & index = 4 & flag_sync_string = 3 => 8 (>)
    fotrh iteration = ">" -> flag_sync_sc = 2 & index = 5 & flag_sync_string = 3 => 10 (all flags desactivated
        at the start of the loop by sync flags resulting in > getting identified as RED_OUT_ID)

    what will happen if we make a scrapper function for each token, the issue arise from extracting one from two,
    (<<<) getting < out of <<, when we increment the delay in the pipe scrap it gets incremented more in the scrapping
    of (<<), so does eliminating that will solve this ?

    **Lets see: (simulation in which the flag_sync_sc will get incremented only in single tokens not the multiones)

    case (ls |>>):
    first iteration + string -> flag_sync_string = 3 & index = 2; => 5 (ls )
    sec iteration = pipe -> flag_sync_sc = 0 & index = 3 & flag_sync_string = 3; => 6 (|)
    third iteration = red_app -> flag_sync_sc = 1 & index = 4 & flag_sync_string = 3 => 8 (>)
    forth iteration = ">" -> flag_sync_sc = 1, (remains the same sinec << is multi-token), & index = 5 & flag_sync_string = 3
    => 9 (no flags desactivating resulting in that > wont get identified as RED_OUT_ID)

    as we see the case of (ls |>>) string, is solved using this
    Lets see now the case of single pipe with >>

    case(|>>)
    first iteration = pipe -> flag_sync_sc = 0 & index = 0; => 0(|)
    sec iteration = red_app -> flag_sync = 1 & index = 1 => 2 all flags desactivated (does not affect) (<)
    third iteration = RED_APP_ID >> -> flag_sync = 1 (remains) & index = 2 => 3; no flags desactivated
    fourth iteration = "<" -> flag_sync = 1 (remains) & index = 3 => 4; all flags desactivated reusltin in (< being identifed)
    it seems that this solution is wont solve all cases

    why not delay as the same as string, the flag_sync_sc will increment as long as the token is multi or sinlge?
   ** Lets try Again: 
    case: |>>
    firs iteration: flag_sync_sc = 0 & index = 0 => 0 (|) we took pipe
    sec iteration: flag_sync_sc = 1 & index = 1 => 2 all flag desacitivated we took <<
    thrid iteration : flag_sync_sc = 3 (cuz we identified >> both) & index = 2 => 5 (non is desactivated)
    GOOD !

    Lets try it with the case of strings:
    case: ls |>>
    first iteration: flag_sync_sc = 0 & index 0 & flag_sync_string = 0 => 0 (ls )
    sec iteration: flag_sync_sc = 0 & index 1 & flag_sync_string = 3 => 4 all flags desactivated (|)
    third iteration: flag_sync_sc = 1 & index = 2 & flag_sync_string = 3 => 6 all flags desctivated (>>)
    fourth iteration: flag_sync_sc = 3 & index = 3 & flag_sync_string = 3 => 9 none is desactivated no > is identified
    SEEMS GOOD!

    ***********************************************************************************************************
    